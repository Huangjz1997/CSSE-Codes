package hardysTaxi;

import java.util.*;

/**
 * Provides the static method hardySolutionsLessThan(N) which finds all "taxicab
 * numbers that are less than n. These are represented as TaxicabNumber objects,
 * which include the sum and two different ways of writing that as a sum of two
 * cubes.
 * 
 * @author Claude Anderson.
 * 
 */
public class Hardy {
	//set records the result of a^2+b^2
	private static TreeSet<Long> set=new TreeSet<>();
	//use ArrayList records ans which can get number by index.
	private static ArrayList<Long> ansList =new ArrayList<>();
	//use TreeSet record ans which can use log(n) to get .contain()
	private static TreeSet<Long> ansSet=new TreeSet<>();
	//avoid the duplicated, a little hard to explain.
	private static ArrayList<Integer>index = new ArrayList<>();
	//Minimal is the current minimal, then delete num less than minimal from the set
	private static int Minimal = 0;
	//Record the current MAX calculate by a^2+b^2
	private static Long MAX = 0L;
	//the size of the AnsList
	private static Long ans = 0L;
	
	
	//return the cube
	private static long cube(int k) {
		long ans = k;
		ans = ans * ans * ans;
		return ans;
	}

	//expand of index
	public static void clear(int k) {
		for (int i =0; i <k; i++) {
			index.add(0);
		}
	}
	
	public static Long init(long MAX) {
		//i is the current a  (a^2+b^2=n)
		int i = Minimal + 1;
		//the min n we can get in this round
		long mini=Long.MAX_VALUE;
		//(a^2+b^2<=MAX)
		while (cube(i) + 1 <= MAX) {
			long tmp1 = cube(i);
			if (i >=index.size())
				clear(10000);
			long tmp2 = cube(index.get(i) + 1);
			//while a^2+b^2<=MAX
			while (tmp1 + tmp2 <= MAX) {
				//update the min b of a
				index.set(i, index.get(i)+1);
				//get n(tmp3)
				long tmp3 = tmp1 + tmp2;
				if (tmp3<mini) mini=tmp3;
				//if it contains, we get a ans
				if (set.contains(tmp3)) {
					//if ansSet doesn't contain tmp3, we get the ans
					if (!ansSet.contains(tmp3)) {
						//Set for log(n) contains
						ansSet.add(tmp3);
						//List for sort and get num by index
						ansList.add(tmp3);
					}
				} else {
					set.add(tmp3);
				}
				//we won't use it again
				if (index.get(i) == i) {
					Minimal = i;
					break;
				}
				tmp2 = cube(index.get(i) + 1);
			}
			i++;
		}
		//delete the num which we won't get again (less than minimal) from TreeSet
		ArrayList<Long> list=new ArrayList<>();
		for(Iterator<Long> iter = set.iterator(); iter.hasNext(); ) { 
			Long tmp=iter.next();
		    if (tmp<mini) list.add(tmp);else break;
		} 
		for (Long k:list){
			set.remove(k);
		}
		
		return (long)ansList.size();
	}

	/**
	 * Find the nth Hardy number (start counting with 1, not 0) and the numbers
	 * whose cubes demonstrate that it is a Hardy number.
	 * 
	 * @param n
	 * @return the nth Hardy number
	 */
	public static long nthHardyNumber(int n) {
		//keep searching until get enough hardyNumber
		while (ans < n) {
			//increase the MAX of the hardyNumber
			MAX = MAX +200000000;
			ans = init(MAX);
		}
		//sort the list
		Collections.sort(ansList);
		return ansList.get(n - 1);
	}

}
