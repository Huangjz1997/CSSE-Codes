package hardysTaxi;

// A height-balanced binary tree with rank that could be the basis for a text editor.

public class EditTree {
	public static Node NULL_NODE = new Node();
	private Node root;
	public Long numOfRotation;
	private Long size;

	/**
	 * Construct an empty tree
	 */
	public EditTree() {
		this.root = NULL_NODE;
		size=0L;
	}

	public EditTree(Node root) {
		this.root = root;
		this.root.updateHeight();
	}

	/**
	 * Construct a single-node tree whose element is c
	 * 
	 * @param c
	 */


	/**
	 * 
	 * @return the height of this tree
	 */
	public int height() {
		return this.root.height;
	}

	/**
	 * 
	 * returns the total number of rotations done in this tree since it was
	 * created. A double rotation counts as two.
	 *
	 * @return number of rotations since tree was created.
	 */
	public Long totalRotationCount() {
		return this.numOfRotation; // replace by a real calculation.
	}



	/**
	 * This one asks for more info from each node. You can write it like the
	 * arraylist-based toString() method from the BST assignment. However, the
	 * output isn't just the elements, but the elements, ranks, and balance
	 * codes. Former CSSE230 students recommended that this method, while making
	 * it harder to pass tests initially, saves them time later since it catches
	 * weird errors that occur when you don't update ranks and balance codes
	 * correctly. For the tree with node b and children a and c, it should
	 * return the string: [b1=, a0=, c0=] There are many more examples in the
	 * unit tests.
	 * 
	 * @return The string of elements, ranks, and balance codes, given in a
	 *         pre-order traversal of the tree.

	/**
	 * 
	 * @param pos
	 *            position in the tree
	 * @return the character at that position
	 * @throws IndexOutOfBoundsException
	 */
	public Long get(int pos) throws IndexOutOfBoundsException {
		if (pos < 0 || pos >= this.root.size())
			throw new IndexOutOfBoundsException();
		return this.root.get(pos);

	}
	

	/**
	 * 
	 * @param c
	 *            character to add to the end of this tree.
	 */
	public void add(Long c) {
		// add c into the rightest of the tree
		size++;
		this.root=this.insert(root, c);
	}
	// helper method of add
	private Node insert(Node root, Long c) {
		// if root==NULL_NODE we just add the new node on the leaf of the tree
		if (root == NULL_NODE)
			return new Node(c);
		// should insert it into left subtree;
		if (root.data.compareTo(c)>0) {
			root.left = insert(root.left, c);
			root.rank++;
		} else if (root.data.compareTo(c)<0)
			root.right = insert(root.right, c);

		// update the height by O(1)
		root.height();
		// if the current node is not balance, rotate it.
		if (Math.abs(root.balance()) > 1)
			return rotation(root);

		return root;
	}

	private Node rotation(Node root) {

		// left is deeper
		if (root.balance() > 0) {
			if (root.left.balance() >= 0) {
				// left child's left is deeper Single Right rotation
				return right_rotation(root);
			}

			if (root.left.balance() < 0) {
				// left child's right is deeper Double Right rotation
				root.left = left_rotation(root.left);
				return right_rotation(root);
			}
		}

		// right is deeper
		if (root.balance() < 0) {
			if (root.right.balance() <= 0) {
				// right child's right is deeper Single Left rotation
				return left_rotation(root);
			}

			if (root.right.balance() > 0) {
				// right child's left is deeper Double Left rotation
				root.right = right_rotation(root.right);
				return left_rotation(root);
			}
		}
		// Impossible to reach here
		return new Node();
	}

	private Node left_rotation(Node root) {
		Node child = root.right;
		// change the rank
		child.rank = root.rank + child.rank + 1;
		// change the relationship
		root.right = child.left;
		child.left = root;
		// update their heights
		root.height();
		child.height();
		return child;
	}

	private Node right_rotation(Node root) {
		Node child = root.left;
		root.rank = root.rank - child.rank - 1;
		// change the relationship
		root.left = child.right;
		child.right = root;
		// update their heights
		root.height();
		child.height();
		return child;
	}

	public boolean contains(Long c){
		return this.contain(root,c);
	}
	private boolean contain(Node root,Long c) {
		if (root==NULL_NODE) return false;
		if (c.equals(root.data)) return true;
		if (root.data.compareTo(c)>0) return contain(root.left, c);
		return contain(root.right, c);
	}

	/**
	 * 
	 * @return the number of nodes in this tree
	 */
	public Long size() {
		return size;
	}
	/**
	 * @return The root of this tree.
	 */
	public Node getRoot() {
		return this.root;
	}

	
	public Long delete(int i) throws IndexOutOfBoundsException {
		// Implementation requirement:
		// When deleting a node with two children, you normally replace the
		// node to be deleted with either its in-order successor or predecessor.
		// The tests assume assume that you will replace it with the
		// *successor*.
		if (i < 0 || i >= this.size())
			throw new IndexOutOfBoundsException();

		// use ans[] to return the delete char
		Long[] ans = new Long[2];
		this.root = this.deleteNode(this.root, i, ans);
		return ans[0];
	}

	// helper method of delete
	public Node deleteNode(Node root, int i, Long[] ans) {
		if (root == NULL_NODE)
			return NULL_NODE;

		// we found the node
		if (root.rank == i) {
			// record the char
			ans[0] = root.data;
			// if it just has one child or no child.
			if (root.left == NULL_NODE)
				return root.right;
			if (root.right == NULL_NODE)
				return root.left;
			// it has two children, we need to find the smallest node in its
			// right subtree
			root.right = delete(root.right, root);
		} else
			// in the left subtree
			if (root.rank > i) {
			root.rank--;
			root.left = deleteNode(root.left, i, ans);
		}
		// in the right sub tree
		else if (root.rank < i)
			root.right = deleteNode(root.right, i - root.rank - 1, ans);

		// update height and rotate if it is unbalanced
		root.height();
		if (Math.abs(root.balance()) > 1)
			return rotation(root);
		return root;
	}

	// find the most left node
	private Node delete(Node root, Node original) {

		// we find it
		if (root.left == NULL_NODE) {
			// change the char
			original.data = root.data;
			return root.right;
		}
		// find it in left subtree
		root.rank--;
		root.left = delete(root.left, original);

		// update height and rotate it if needed
		root.height();
		if (Math.abs(root.balance()) > 1)
			return rotation(root);
		return root;
	}
}
