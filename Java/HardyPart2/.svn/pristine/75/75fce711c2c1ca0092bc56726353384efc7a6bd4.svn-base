package hardysTaxi;

// A node in a height-balanced binary tree with rank.
// Except for the NULL_NODE (if you choose to use one), one node cannot
// belong to two different trees.

public class Node {


	// The fields would normally be private, but for the purposes of this class,
	// we want to be able to test the results of the algorithms in addition to
	// the
	// "publicly visible" effects

	int height;
	Long data;
	Node left, right; // subtrees
	int rank; // inorder position of this node within its own subtree.

	public Node() {
		this.left = null;
		this.right = null;
		this.height = -1;
	}

	// You will probably want to add several other methods

	public Node(Long c) {
		this.data = c;
		this.rank = 0;
		this.right = EditTree.NULL_NODE;
		this.left = EditTree.NULL_NODE;
		this.height = 0;
	}

	// For the following methods, you should fill in the details so that they
	// work correctly
	
	//update the whole tree height
	public void updateHeight(){
		if (this==EditTree.NULL_NODE) return;
		this.left.updateHeight();
		this.right.updateHeight();
		this.height();
	}
	
	//update this node's height by O(1) 
	public int height() {
		this.height = Math.max(this.left.height, this.right.height) + 1;
		return this.height;
	}

	//return the difference height between left and right subtree
	public int balance() {
		return this.left.height-this.right.height;

	}


	public int size() {
		if (this == EditTree.NULL_NODE)
			return 0;
		//rank is its size of left subtree
		return this.rank + this.right.size() + 1;
	}


	public Long get(int pos) {
		//we find it 
		if (this.rank == pos)
			return this.data;
		if (this.rank > pos)
			return this.left.get(pos);
		return this.right.get(pos-this.rank-1);
	}

	

}